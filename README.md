# git-lesson-05-10

Hello world 
# Инструкция по работе с Git и удалёнными рупозиториями

## Что такое Git?
__*Git*__ - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.
## Подготовка репозитория
Для создания репозитория необходимо выполнить команду __*git unint*__ в папке с репозиторием и у Вас создаться репозиторий (появится скрытная папка .git)

## Создание соммитов

### Git add
Для добавления изменений в коммит используется команда __*git add*__. Чтобы использовать команду *git add* напишите __*git add <имя файла>*__

### Просмотр состояния репозитория
Для того, чтобы посмотреть состояние репозитория используется команда __*git status*__. Для этого необходимо в папке с репозиторием написать __*git status*__, и вы увидите были ли изменения в файлах, или их не бало.

### Создание коммитов
Для того, чтобы создать коммит(сохранение) необходимо выполнить команду __*git commit*__. Выполняется она так: __*git commit -m "<сообщение к коммиту>"*__. Все файлы для коммита должны быть добавлены и сообщение к коммиту писать обязательно.

__*git commit -am*__ - Если файл имеет состояние modified (т.е был tracked ранее и мы его добавили с помощью git add), то можно пропустить этап с командой __*git add*__ посредством использования данной команды.

### Перемещение между сохранениями
Для того, чтобы перемещаться между коммитами, используется команда __*git checkout*__. Используется она в папке с пепозиторием следующим образом: __*git checkout <номер коммита>*__.

### Журнал изменений
Для того, чтобы посмтреть все сделанные изменения в репозитории, используется команда __*git log*__. Для этого достаточно выполнить команду __*git log*__ в папке с репозиторием.

## Ветки в Git

### Создание ветки
Для того, чтобы создать ветку, используется команда __*git branch*__. Делается это следующим образом в папке с репозиторием: __*git branch <название новой ветки>*__.

### Слияние веток
Для того чтобы дабавить ветку в текущую ветку используется команда __*git merge*__.

### Удаление веток
Для удаления ветки ввести команду __*git branch -d 'name branch'*__




# Прочий материал после обучения со 1 урока...

+ **git add "file_name"** - Добавить файлу с названием file_name версионность
+ **git reset .** - Убрать у всех файлов в папке версионность
+ **git reset "file_name"** - Удалить у файла с названием file_name версионность
+ **git checkout "hash_number"** - Переместить на коммит с хэшем "hash_number" (для того, чтобы вернуться git checkout master/main)
+ **git diff** - Последние изменения (начиная от коммитапше )


# Команды со 2 семинара

+ **cd** - Переместиться внутрь папки
+ **cd ..** - Переместиться из папки
+ **mkdir** - Создать новуб папку
+ **ls** - Посмотреть список файлов в папке
+ **new-item** - Создать новый файл
+ **git branch** - Проверить список существующих веток
+ **git branch branch_name** - Создать ветку с названием иbranch_name
+ **git checkout -b branch_name** - Создать ветку с названием branch_name и переместиьтся в неё.
+ **git merge branch_name** - Слить в тоекущую ветку изменения из branch_name
+ **git branch -D branch_name** - Удалить еще не слитую ветку
+ **git branch -d branch_name** - удалить уже слитую ветку

# Скриншот с решением конфликта
На данном скрине будет видно решение конфликта после применения команды *git merge*
![не удалось загрузить изображение...](photo_2023-10-04_15-39-54.jpg)


# Материал с 3 урока "Работа с удалёнными репозиториями"
**Удаленный (иногда говорят "внешний") репозиторий** – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.

Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.

## Добавление удаленного репозитория к существующему локальному. 
### Команда git remote add
Как добавить удаленный репозиторий к вашему локальному репу? Для этого в Git есть команда git remote add.

+ **Формат**: _git remote add <название удаленного репозитория> <ссылка на удаленный репозиторий>_
+ **Что делает**: _Подключает удаленный репозиторий к вашему под переданным именем._
+ **Пример**: _Подключим удаленный репозиторий под именем origin $ git remote add origin git@github.com:smartiqaorg/geometric_lib.git_

Имя удаленного репозитория в команде git remote add вы можете придумать сами. Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени. Принято называть удаленный репозиторий origin, но строго говоря, никаких ограничений здесь нет.

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку Code на странице репозитория на GitHub

![Не удалось загрузить изображение...](https://thumb.tildacdn.com/tild6336-6565-4834-b433-616638643930/-/resize/960x/-/format/webp/2_git_fetch_pull_pus.png)

## Клонирование удаленного репозитория.
### Команда git clone.

Теперь, когда мы разобрались с настройкой подключения удаленного репозитория к уже существующему, давайте узнаем, как можно склонировать удаленный репозиторий к себе на компьютер. Операция клонирования создаёт на вашем компьютере точную копию удаленного репозитория.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда *git clone*.

+ **Формат**: _git clone <ссылка на удаленный репозиторий>_
+ **Что делает**: _Клонирует переданный репозиторий на ваш компьютер._
+ **Пример**: _Склонируем себе репозиторий geometric_lib
$ git сlone https://github.com/smartiqaorg/geometric_lib.git_

Ссылку на удаленный репозиторий можно получить тем же способом, что мы разбирали выше. Нужно нажать на зеленую кнопку Code на главной странице репозитория на GitHub.

## Получение изменений из удаленного репозитория.
### Команда git pull

Часто хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она **git pull**.

+ **Формат**: _git pull [ключи] [имя удаленного репозитория]_
+ **Что делает**: _Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. По умолчанию слияние удаленной ветки с локальной происходит именно в fast-forward режиме, так что включать его специально не требуется_
+ **Пример**: _Обновим нашу рабочую копию в соответствии с удаленным репозиторием
$ git fetch origin_

На самом деле, новых команд здесь нет. Команда *git pull* это просто сокращение последовательного применения *git fetch и git merge*. Но используется *git pull* намного чаще.

## Отправка изменений в удаленный репозиторий.
### Команда git push
Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. Для этого в Git существует команда git push.

+ **Формат**: _git push [ключи] [имя удаленного репозитория] [имя ветки]_
+ **Что делает**: _Загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме fast-forward, и при этом не был передан ключ force, выполнение закончится с ошибкой._
+ **Пример**: _Загрузим все изменения с текущей ветки в удаленный репозиторий
$ git push origin develop_

По факту данная команда аналогична связке git fetch + git merge, но выполненной из удаленного репозитория (это просто аналогия, на самом деле так сделать не получится).

Давайте более подробно разберем, как работает эта команда. Допустим, мы выполнили git push origin develop в нашем локальном репозитории. Возможны три варианта развития событий.

Если изменения с нашей ветки можно слить с удаленной веткой в режиме fast-forward, то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.

Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме fast-forward выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.

Но если вы вдруг передали флаг --force, то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага – --force-with-lease. Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка. Таким образом, вы не попадете в ситуацию, когда вы случайно удалили чужой коммит.

# GitHub. Работа с репозиторием, создание форков и пулл-реквестов

Научившись работать с локальным репозиторием, освоим основы работы с GitHub. Итак, если коротко, то GitHub – это, наверное, самый популярный сервис бесплатного хостинга удаленных репозиториев с множеством дополнительных функций. Среди них есть, например, создание issue – запросов, в которых можно сообщить разработчикам об ошибках, создание репозиториев-форков и пулл-реквестов. Кроме того, на GitHub можно подписаться на обновления какого-то конкретного пользователя или включить отслеживание репозитория вашего любимого проекта. Все это превращает GitHub в настоящую социальную сеть для разработчиков по всему миру. Давайте приступим к изучению основ работы с этим сервисом.

## Создание репозитория на GitHub
Прежде всего вам необходимо зарегистрироваться на GitHub, но это довольно тривиальный процесс, так что его мы здесь опустим. После регистрации вы попадете на главную страницу. На ней будут отображаться действия людей, на которых вы подписались и обновления в репозиториях, которые вы добавили в избранное.

Чтобы создать свой репозиторий, нажмите на зеленую кнопку New, как показано на рисунке.
![не удалось загрузить изображение...](https://thumb.tildacdn.com/tild3634-3937-4832-b231-636530316535/-/resize/960x/-/format/webp/9_git_fetch_pull_pus.png)

Перед вами откроется страница создания репозитория. Давайте разберем, что за поля нам предлагают заполнить.

1. Итак, первое поле **Repository name** – имя репозитория. Здесь все просто, вам нужно придумать имя, которое будет отображаться на странице вашего репозитория. Здесь нет никаких ограничений, но старайтесь давать как можно более содержательные имена своим репозиториям.
2. Второе поле – **Description** – описание. Его заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните графу описания.
3. Затем вы можете выбрать, будет ли репозиторий открытым, то есть доступным абсолютно всем пользователям GitHub, или закрытым, то есть доступным только вам и людям, которым вы предоставите доступ.
4. Последние три поля предлагают нам добавить, соответственно, **README-файл**, **.gitignore** файл и выбрать лицензию для нашего проекта.

После заполнения полей страница выглядит примерно так.
![не удалось загрузить изображение...](https://thumb.tildacdn.com/tild3935-6465-4134-b838-663333396336/-/resize/896x/-/format/webp/10_git_fetch_pull_pu.png)

Заметьте, мы не стали вводить описание репозитория, поскольку решили добавить в него **README-файл**, хотя иногда и можно продублировать самую основную информацию из **README** в описании.

Завершим процесс создания репозитория, нажав кнопку **Create repository**.

## Страница репозитория на GitHub

После создания репозитория, мы попадем на его страницу на GitHub. В нашем случае эта страница будет выглядеть так.
![не удалось загрузить изображение...](https://thumb.tildacdn.com/tild3635-3534-4631-b637-363766623533/-/resize/960x/-/format/webp/11_git_fetch_pull_pu.png)

Как видно из рисунка, GitHub автоматически создал первый коммит, добавив в него файл **.gitignore** и файл **README**.

Кстати, можно заметить, что содержимое файла **README** выводится под рабочей копией репозитория. Это одна из особенностей GitHub. Вы в любое время можете создать файл с именем **README.md** и запушить его в свой удаленный репозиторий на GitHub. Тогда содержимое этого файла будет отображаться прямо на странице вашего репозитория.

В верхнем меню мы видим 9 разных вкладок. Давайте разберем их по порядку.

1. Вкладка **Code**. Сейчас открыта именно она. В ней содержится рабочая копия нашего репозитория (по центру), описание (справа), вывод файла **README** (под рабочей копией), история коммитов, а также кнопки для клонирования репозитория и просмотра файлов.
2. Вкладка **Issues**. В этой вкладке будут отображаться все запросы, сделанные другими пользователями. Как правило, пользователи используют запрос, чтобы сообщить о найденном баге, либо чтобы задать какой-то вопрос о вашем приложении.
3. Вкладка **Pull-requests**. На этой вкладке будут отображаться все пулл-реквесты, сделанные другими пользователями. О том, что такое пулл-реквесты, мы поговорим ниже.
4-5. Вкладки **Actions** и **Project** относятся скорее к системе **CI/CDI**, которую предоставляет GitHub, в этом курсе мы не будем затрагивать их.
6. Вкладка **Wiki** открывает вам доступ к созданию и размещению документации о собственном проекте.
7. На вкладке **Security** содержатся различные настройки безопасности вашего проекта. Там же можно включить инспекцию вашего кода, чтобы узнать, если вы случайно загрузите какой-нибудь секретный токен на GitHub.
8. Вкладка **Insight** содержит различную информацию и статистические данные об активности репозитория. Там вы сможете посмотреть на зависимость количества коммитов в репозитории от времени или на процент коммитов, сделанных вами.
9. Последняя вкладка – **Settings**. В ней находятся различные настройки вашего репозитория. Там вы можете поменять видимость репозитория, сделав его частным, или вовсе удалить репозиторий.

## Создание форка репозитория на GitHub. Пулл-реквесты

Итак, одной из самых важных частей GitHub является создание форков.

+ **Форк (от англ. fork – вилка)** – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.
+ **Пулл-реквест (от англ. pull-request – запрос pull)** – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный code-review с указанием всех неточностей.

Теперь давайте рассмотрим пайплайн контрибуции (англ. contribution – внесение вклада) на примере реального репозитория. То есть научимся вносить свой вклад в разработку проектов с открытым исходным кодом на GitHub.

1. Для начала зайдем на страницу репозитория проекта. Нажимаем на кнопку Fork, как показано на картинке. После этого Git создаст точную копию этого репозитория в вашем аккаунте.
![Изображение не загрузилось](https://thumb.tildacdn.com/tild6139-3866-4266-b562-383466366537/-/resize/900x/-/format/webp/12_git_fetch_pull_pu.png)
![Изображение не загрузилось](https://thumb.tildacdn.com/tild6166-6564-4437-a232-316433383366/-/resize/960x/-/format/webp/13_git_fetch_pull_pu.png)
2. Клонируем репозиторий к себе на компьютер командой git clone. Создадим файл README.md с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.

3. Сделаем коммит и выполним git push, чтобы загрузить наши изменения в удаленный репозиторий.

4. Теперь GitHub подсказывает нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать пулл-реквест.
![Изображение не загрузилось](https://thumb.tildacdn.com/tild6665-3737-4233-b431-643064363832/-/resize/960x/-/format/webp/14_git_fetch_pull_pu.png)
5. Нажимаем на кнопку Compare на подсказке GitHub, либо переходим на вкладку Pull Requests и нажимаем New pull request.
![Изображение не загрузилось](https://thumb.tildacdn.com/tild3937-3762-4239-b835-316636363135/-/resize/960x/-/format/webp/15_git_fetch_pull_pu.png)
6. Перед нами откроется страница создания пулл-реквеста.
![Изображение не загрузилось](https://thumb.tildacdn.com/tild3461-6636-4339-b038-343162346365/-/resize/960x/-/format/webp/16_git_fetch_pull_pu.png)
Здесь мы можем просмотреть внесенные изменения и выбрать две ветки: одну в исходном репозитории, на нее будут залиты наши изменения, вторую – в нашем репозитории, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку Create pull request.

7. Теперь мы попадаем на страницу описания наших изменений.
![Изображение не загрузилось](https://thumb.tildacdn.com/tild6632-3063-4466-a662-616162613337/-/resize/960x/-/format/webp/17_git_fetch_pull_pu.png)
Здесь необходимо описать, что за изменения вы внесли и почему они были необходимы. Сообщение, которое оставили мы, видно на картинке. Оно отражает суть и необходимость внесенных изменений. Как только мы закончили с описанием, можно нажимать кнопку Create pull request.

8. Теперь мы попадаем на страницу уже созданного пулл-реквеста в изначальном репозитоии. В нашем случае он выглядит так.
![Изображение не загрузилось](https://thumb.tildacdn.com/tild3061-6630-4031-b832-613663646138/-/resize/960x/-/format/webp/18_git_fetch_pull_pu.png)
Именно так будет выглядеть наш пулл-реквест и для владельца репозитория. На этой странице он сможет писать комментарии, указывая на ошибки или задавая вопросы. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.

# Модель ветвления Git
В этом разделе мы познакомимся с наиболее удачной моделью организации ветвления в большом проекте.
## Центральный репозиторий
Итак, основой нашей модели будет центральный репозиторий. Строго говоря, в Git не может быть никаких центральный репозиториев, поскольку это распределенная система контроля версий. Поэтому центральный репозиторий является таковым только с точки зрения логики его использования, с технической же точки зрения – это точно такой же репозиторий, как и все остальные. У каждого из разработчиков в команде есть копия основного репозитория. Схематически ситуация выглядит так.
![Изображеиен не загрузилось](https://thumb.tildacdn.com/tild6235-6637-4666-a431-333264373236/-/resize/768x/-/format/webp/19_git_fetch_pull_pu.png)
Центральный репозиторий на картинке назван origin. Как мы уже упоминали выше, это одно из общепринятых наименований в Git.

Процесс разработки построен на том, что каждый разработчик пушит свой код в основной репозиторий и пуллит код других разработчиков из него. Кроме того, допускаются ситуации, когда разработчики обмениваются кодом друг с другом, – минуя центральный репозиторий. Необходимость такого обмена может возникнуть, когда, например, два девелопера работают над одной функцией. В таком случае им необходим код друг друга, но пушить не готовую функцию в основной репозиторий ни один из них не может. Взаимодействие между разработчиками и основным репозиторием изображены на картинке выше с помощью стрелок.

## Основные ветки
В нашей модели существуют две главные ветки:
1. **main** – ветка, в которой содержится только код, готовый к релизу.
2. **develop** – ветка, в которой содержатся изменения, готовые ко включению в последующий релиз.

Эти ветви называются главными, поскольку существуют в центральном репозитории и всех его копиях все время. Логика работы с ними не предполагает их удаления после выпуска очередного релиза, в отличие от, например, вспомогательных ветвей группы **release**.

Как только в ветке **develop** появляется достаточно изменений для создания нового релиза, она вливается в ветку **main** (напрямую или посредством создания специальной ветки release-*, о которой мы поговорим позже). После чего соответствующий коммит слияния в ветке main помечается тегом с указанием версии релиза (напомним, что тег – это статический указатель, нужный для удобства переключения между коммитами).

Таким образом, коммит в ветке **origin/main** означает выпуск нового релиза. Кстати, если строго придерживаться этого правила, можно организовать непрерывную интеграцию при помощи как встроенных средств GitHub, так и сторонних инструментов, специализирующихся на **CI/CDI**.

## Вспомогательные ветки
Чтобы поддерживать независимость разработки отдельных частей проекта, наша модель включает в себя несколько групп вспомогательных ветвей. Главное отличие таких ветвей от главных в том, что срок жизни этих ветвей ограничен. После завершения выполнения определенной работы, вспомогательная ветвь вливается в одну из главных, после чего удаляется.

Наша модель предполагает существование следующих групп вспомогательных ветвей:
1. Ветви для разработки новых функций. Они же **feature branches**.
2. Ветви релизов, то есть **release branches**.
3. Ветви срочных исправлений – **hotfix branches**.

Чуть ниже мы разберем предназначение каждой группы. Кроме того, мы договоримся о правилах создания, именования и слияния ветвей из каждой группы. Конечно, Git не ограничивает ни в именах ветвей, ни в чем либо другом, – эти условности мы придумываем сами. Тем не менее, такие правила необходимы для облегчения взаимодействия нескольких разработчиков внутри одного большого проекта.

## Feature-ветки
Могут порождаться от: **develop**
Могут вливаться в: **develop**
Правило именования: любое имя, кроме **main, develop, release-*, hotfix-*.**

Ветки функциональности используются для разработки новых функций, для которых неизвестно: будут ли они добавлены в ближайший релиз или же в какой-то более поздний. Основной смысл такой ветки в том, что живет она ровно столько, сколько продолжается разработка функции, для которой была создана эта ветка. В это время в ветке main могут выходить релизы, не затрагивающие разрабатываемую функцию. По завершении создания функции, такая ветка либо вливается в ветку develop, либо удаляется, если эксперимент с новой функцией не удался.

Feature-ветки существуют в основном только в репозиториях разработчиков, но могут на некоторое время появиться и в центральном репозитории.

Графически взаимодействие разработчика с feature-веткой выглядит примерно так:
![Изображение не загрузилось...](https://thumb.tildacdn.com/tild3934-3330-4637-b236-306530323334/-/resize/768x/-/format/webp/20_git_fetch_pull_pu.png)

### Продолжение следует...